#!/bin/sh
#
#

set -e

direnv_find_rc() {
  while true; do
    if [ -f ".envrc" ]; then
      return 0
    fi
    if [ `pwd` = '/' ]; then
      return 1
    fi
    cd ..
  done
}

#### stdlib ##################

has() {
  type "$1" >/dev/null 2>&1
  return $?
}

PATH_add() {
  export PATH="`readlink -f "$1"`:$PATH"
}

layout_ruby() {
  PATH_add 'vendor/gems/bin'
  PATH_add 'bin'
  export RUBYLIB=$PWD/lib
  export GEM_HOME=$PWD/vendor/gems
}

layout() {
  eval "layout_$1"
}

if has rvm; then
  # source rvm on first call, haha :)
  rvm() {
    if [ -z "$rvm_scripts_path" ]; then
      echo "rvm: \$rvm_scripts_path not found"
      exit 1
    fi
    unset rvm
    . "$rvm_scripts_path/rvm"
    rvm $@
  }
fi

#### end stdlib #############

if direnv_find_rc; then
  unset direnv_find_rc
  if [ -n "$DIRENV_BACKUP" ]; then
    if [ "$DIRENV_DIR" = "`pwd`" ]; then
      # env already loaded
      exit 0
    fi
    eval `direnv diff "$DIRENV_BACKUP"`
  fi
  DIRENV_BACKUP=`direnv dump`
  DIRENV_DIR=$PWD
  echo "direnv: loading $PWD" >&2
  export DIRENV_BACKUP DIRENV_DIR
  if [ -n "$DIRENV_CONTEXT" ]; then
    . .env.$DIRENV_CONTEXT >&2
  else
    . "$PWD/.envrc" >&2
  fi
  direnv diff -r "$DIRENV_BACKUP"
else
  if [ -n "$DIRENV_BACKUP" ]; then
    echo "direnv: unloading $DIRENV_DIR" >&2
    direnv diff "$DIRENV_BACKUP"
  fi
fi
